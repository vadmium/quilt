#! @BASH_SHEBANG@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.

# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r $QUILT_DIR/scripts/patchfns ]
	then
		echo "Cannot read library $QUILT_DIR/scripts/patchfns" >&2
		exit 1
	fi
	. $QUILT_DIR/scripts/patchfns
fi

usage()
{
	printf $"Usage: quilt delete [-r] [--backup] [patch|-n]\n"
	if [ x$1 = x-h ]
	then
		printf $"
Remove the specified or topmost patch from the series file.  If the
patch is applied, quilt will attempt to unapply it first.

-n	Delete the next patch after topmost, rather than the specified
	or topmost patch.

-r	Remove the deleted patch file from the patches directory as well.

--backup
	Rename the patch file to patch~ rather than deleting it.
	Ignored if not used with \`-r'.

-f	Force remove even if the patch is applied and has unrefreshed
	changes.

-R	Always verify if the patch is refreshed; don't rely on timestamp
	checks.
"

		exit 0
	else
		exit 1
	fi
}

find_common_applied_files()
{
	# We can find all the files that are touched by some patch not
	# this one by listing all of the unique files touched by the other
	# patches, concatenating with all of the unique files touched by
	# this patch, and finding duplicates.
	local patch=$1
	(
		for other_patch in $(applied_patches)
		do
			if [ "$other_patch" != "$patch" ]
			then
				files_in_patch $other_patch
			fi
		done | sort | uniq ; \
		files_in_patch $patch | sort | uniq
	) | sort | uniq -d
}


unset opt_pop

options=`getopt -o nrhfR --long backup,help -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi

eval set -- "$options"

while true
do
	case "$1" in
	-n)
		opt_next=1
		shift ;;
	-r)
		opt_remove=1
		shift ;;
	-h|--help)
		usage -h ;;
	--backup)
		QUILT_BACKUP=1
		shift ;;
	-f | -R)
		opt_pop="${opt_pop+$opt_pop }$1"
		shift ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -gt 1 -o \( -n "$opt_next" -a $# -gt 0 \) ]
then
	usage
fi

if [ -n "$1" ]; then
	patch=$(find_patch "$1") || exit 1
else
	patch=$(top_patch)
fi
if [ -n "$opt_next" ]
then
	if ! patch=$(patch_after "$patch")
	then
		printf $"No next patch\n" >&2
		exit 1
	fi
fi
if [ -z "$patch" ]
then
	# find_top_patch will display the proper error message for us
	find_top_patch > /dev/null
	exit 1
fi

# Verify that the list of files in this patch is disjoint from the
# set of files in all the other currently-applied patches.
common_files=$(find_common_applied_files "$patch")
if [ -n "$common_files" ]
then
	echo "Patch $patch is not independent of other applied patches." >&2
	echo "Common files are:" >&2
	echo $common_files >&2
	exit 1
fi

printf $"Removing patch %s\n" "$(print_patch $patch)"
$QUILT_LIB/backup-files $silent -r -t -B $QUILT_PC/$patch/ -

# Remove the patch from the patch stack
remove_from_db "$patch" || return 1
rm -rf $QUILT_PC/$patch/
rm -f $QUILT_PC/$patch~refresh

if remove_from_series "$patch"
then
	printf $"Removed patch %s\n" "$(print_patch "$patch")"
else
	printf $"Failed to remove patch %s\n" "$(print_patch "$patch")" >&2
	exit 1
fi

patch_file=$(patch_file_name "$patch")
if [ "$opt_remove" -a -e "$patch_file" ]
then
	if [ "$QUILT_BACKUP" ]
	then
		if ! mv -f "$patch_file" "$patch_file~"
		then
			printf $"Failed to backup patch file %s\n" \
				"$patch_file" >&2
			exit 1
		fi
	else
		if ! rm -f "$patch_file"
		then
			printf $"Failed to remove patch file %s\n" \
				"$patch_file" >&2
			exit 1
		fi
	fi
fi
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
